<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Elite Z - Blueprint Editor</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/drawflow/dist/drawflow.min.css">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background-color: #1e1e1e;
      font-family: 'Consolas', monospace;
      height: 100vh;
      overflow: hidden;
      color: #dcdcdc;
    }

    #drawflow {
      width: 100vw;
      height: 100vh;
      background-color: #1e1e1e;
      background-image: linear-gradient(to right, rgba(255,255,255,0.05) 1px, transparent 1px),
                        linear-gradient(to bottom, rgba(255,255,255,0.05) 1px, transparent 1px);
      background-size: 20px 20px;
    }

    .drawflow-node {
      background-color: #2b2b2b !important;
      border: 2px solid #444;
      border-radius: 6px;
      color: #dcdcdc;
      box-shadow: 0 0 6px #000;
      transition: border-color 0.2s, box-shadow 0.2s;
    }

    .drawflow-node h3 {
      margin: 4px;
      font-size: 14px;
      color: #87ceeb; /* UE4-style light cyan titles */
    }
    .drawflow-node label, .drawflow-node small {
        color:rgba(255, 255, 255, 0.72);
    }
    .drawflow-node b {
        color:rgb(0, 106, 255);

    }
    .drawflow-node input,
    .drawflow-node select,
    .drawflow-node textarea {
      background: #1a1a1a;
      border: 1px solid #555;
      color: #dcdcdc;
      width: 100%;
      padding: 4px;
      font-family: monospace;
    }

    .drawflow .connection .main-path {
      stroke: #87ceeb;
      stroke-width: 2px;
    }

    .drawflow-node:hover {
    border-color: #ff4444 !important;
    box-shadow: 0 0 10px #ff444488;
    }

    /* Selected = green border */
    .drawflow-node.selected {
    border-color: #00ff66 !important;
    box-shadow: 0 0 12px #00ff6688;
    }
    .drawflow-node.custom-selected,
    .drawflow-node.custom-selected:hover {
    border-color: #00ff66 !important;
    box-shadow: 0 0 12px #00ff6688;
    }

    .drawflow-node:hover {
    border-color: #ff4444 !important;
    box-shadow: 0 0 10px #ff444488;
    }

    #toolbox {
    position: fixed;
    top: 16px; left: 16px;
    z-index: 99;
    background: #181a21ee;
    border-radius: 13px;
    box-shadow: 0 4px 28px #000d;
    width: 278px;
    min-height: 90px;
    max-height: 94vh;
    display: flex;
    flex-direction: column;
    padding: 8px 8px 10px 8px;
    gap: 5px;
    }
    #toolbox-tabs {
    display: flex;
    gap: 3px;
    margin-bottom: 2px;
    flex-wrap: wrap;
    }
    .toolbox-tab {
    flex: 1 1 0;
    background: #16181f;
    border: none;
    color: #0ff;
    font-weight: 600;
    padding: 7px 6px;
    border-radius: 6px 6px 0 0;
    cursor: pointer;
    font-size: 14px;
    letter-spacing: 0.02em;
    outline: none;
    transition: background 0.18s, color 0.18s;
    }
    .toolbox-tab.active {
    background: #23273b;
    color: #fff;
    z-index: 1;
    }
    .toolbox-tab:not(.active):hover {
    background: #0ff1;
    color: #fff;
    }
    #toolbox-search {
    width: 100%;
    box-sizing: border-box;
    padding: 7px 11px;
    margin: 2px 0 5px 0;
    border-radius: 5px;
    border: 1px solid #23283e;
    font-size: 13px;
    background: #14161b;
    color: #0ff;
    }
    #toolbox-list {
    flex: 1 1 auto;
    display: flex;
    flex-direction: column;
    gap: 3px;
    min-height: 50px;
    }
    .toolbox-btn {
    display: block;
    width: 100%;
    padding: 10px 11px;
    margin: 0;
    font-family: 'Consolas', monospace;
    font-size: 13px;
    color: #fff;
    background: linear-gradient(145deg, #20232c, #181b22);
    border: 1px solid #23283e;
    border-radius: 6px;
    text-align: left;
    cursor: pointer;
    box-shadow: 0 1px 3px #0003;
    transition: all 0.15s;
    }
    .toolbox-btn:hover {
    background: #171b22;
    color: #0ff;
    border-color: #0ff;
    }
    .toolbox-btn:active {
    background: #11131a;
    }
    .toolbox-empty {
    color: #888;
    text-align: center;
    padding: 20px 4px;
    font-size: 14px;
    }

    .toolbox-btn:focus {
        outline: none;
        box-shadow: 0 0 0 2px #0ff inset;
    }
    .top-right-corner {
    position: absolute;
    top: 15px;
    right: 15px;
    z-index: 999;
    }

    .back-btn {
    font-family: 'Consolas', monospace;
    font-size: 13px;
    color: #fff;
    background: linear-gradient(145deg, #222, #111);
    border: 1px solid #444;
    padding: 8px 14px;
    border-radius: 6px;
    cursor: pointer;
    box-shadow: inset 0 0 0 1px #000, 0 2px 4px rgba(0, 0, 0, 0.5);
    transition: all 0.2s ease-in-out;
    }

    .back-btn:hover {
    background: linear-gradient(145deg, #2a2a2a, #181818);
    color: #ff5555;
    border-color: #ff5555;
    }

    .back-btn:active {
    transform: scale(0.97);
    background: #0a0a0a;
    box-shadow: inset 0 0 5px #ff5555;
    }

  </style>
</head>
<body>
    <div id="toolbox">
        <div id="toolbox-tabs">
            <button class="toolbox-tab active" data-cat="Malware">ü¶† Malware</button>
            <button class="toolbox-tab" data-cat="Logic">‚öôÔ∏è Logic</button>
            <button class="toolbox-tab" data-cat="Monitoring">üñ•Ô∏è Monitoring</button>
            <button class="toolbox-tab" data-cat="Main">üö© Main</button>
            <button class="toolbox-tab" data-cat="File">üóÉÔ∏è File</button>
        </div>
        <input id="toolbox-search" type="text" placeholder="Search..." autocomplete="off" />
        <div id="toolbox-list"></div>
    </div>


    <div id="dropzone"
        style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:200;display:none;align-items:center;justify-content:center;background:rgba(24,26,33,0.93);color:#00ffe0;font-size:30px;">
        <div>Drop blueprint JSON here to load</div>
    </div>

    <div class="top-right-corner">
        <button class="back-btn" onclick="window.location.href='/main'">Main Menu</button>
        <button class="back-btn" onclick="window.location.href='/vm'">Sandbox</button>
    </div>

  <div id="drawflow"></div>

  <script src="https://cdn.jsdelivr.net/npm/drawflow/dist/drawflow.min.js"></script>
  <script>


    let nodeInfo = {
        "Start": {
        html: `<div><h3>‚ñ∂Ô∏è Start</h3><label>Main Function!</label></div>`,
        inputs: 0, outputs: 1, name: "Start"
        },
        "ScreenMelter": {
        html: `<div><h3>üî• Screen Melter</h3><label>Strength</label><input type="range" min="1" max="10" value="5"></div>`,
        inputs: 1, outputs: 1, name: "ScreenMelter"
        },
        "IfCond": {
        html: `<div>
            <h3>üß© IF Boolean Only</h3>
            <label>Condition</label>
            <div style="margin-top:12px;font-size:13px;">
            <b>True:1. output</b><br>
            <b>False:2. output</b>
            </div>
        </div>`,
        inputs: 1, // exec + value (boolean)
        outputs: 2, // true, false
        name: "IfCond"
        },

        "Variable": {
        html: `<div>
            <h3>üì¶ Variable</h3>
            <label>Name</label>
            <input type="text" value="myVar" class="var-name" style="width:90%" /><br>
            <label>Type</label>
            <select class="var-type" style="width:100%" onchange="this.parentElement.querySelector('.var-value').type=this.value=='boolean'?'checkbox':this.value">
            <option value="boolean">Boolean</option>
            <option value="string">String</option>
            <option value="number">Number</option>
            </select><br>
            <label>Value</label>
            <input class="var-value" type="checkbox" />
        </div>`,
        inputs: 0,
        outputs: 0,
        name: "Variable"
        },

        "VariableGet": {
        html: `<div>
            <h3>üîé Get Variable</h3>
            <label>Name</label>
            <select class="var-get-name"></select>
        </div>`,
        inputs: 1,    // "exec" (when to get value)
        outputs: 1,   // Value output (wired to IfCond or anything)
        name: "VariableGet"
        },

        "VariableSet": {
        html: `<div>
            <h3>‚úèÔ∏è Set Variable</h3>
            <label>Name</label>
            <select class="var-set-name"></select><br>
            <label>Value</label>
            <input class="var-set-value" type="text" />
        </div>`,
        inputs: 2, // exec, and value (could be 1 and let value come from UI or wire)
        outputs: 1, // exec out (for chaining)
        name: "VariableSet"
        },

        "Ransomware": {
        html: `<div>
        <h3>üîê Ransomware</h3>
        <label>Ransom Note</label><br>
        <textarea rows="6" style="width:100%;background:#1a1a1a;color:#fff;border:1px solid #555;font-family:monospace;font-size:14px;">
        Hello, this is RansomJokey.
        Your files have been encrypted.

        Pay $300 in BTC to get the decryption key.
        You have 48 hours or your files are gone forever.
        </textarea>
        </div>`,
        inputs: 1, outputs: 1, name: "Ransomware"
        },
        "TriggerBSOD": {
        html: `<div><h3>üíÄ Trigger BSOD</h3><small>Instant crash</small></div>`,
        inputs: 1, outputs: 1, name: "TriggerBSOD"
        },
        "PopupSpam": {
        html: `<div><h3>‚ö†Ô∏è Popup Spam</h3><label>Count</label><input type="number" value="10" min="1"></div>`,
        inputs: 1, outputs: 1, name: "PopupSpam"
        },
        "Keylogger": {
        html: `<div><h3>‚å®Ô∏è Keylogger</h3><label>To file:</label><input value="log.txt"></div>`,
        inputs: 1, outputs: 1, name: "Keylogger"
        },
        "CryptoMiner": {
        html: `<div><h3>‚õèÔ∏è Crypto Miner</h3><label>Mining Power</label><input type="range" min="1" max="100" value="30"></div>`,
        inputs: 1, outputs: 1, name: "CryptoMiner"
        },
        "BackgroundChanger": {
        html: `<div><h3>üé® Background Changer</h3><label>Url</label><input type="text" value="enter_url"></div>`,
        inputs: 1, outputs: 1, name: "BackgroundChanger"
        },
        "PopupShow": {
        html: `<div>
            <h3>üí¨ Popup Messagebox</h3>
            <label>Use Variable</label>
            <input type="checkbox" class="popup-use-var">
            <label id="popupmsg">Message</label>
            <input type="text" class="popup-msg-input" value="placeholder text">
        </div>`,
        inputs: 1, outputs: 1, name: "PopupShow"
        },
        "RAT": {
        html: `<div><h3>üêÄ RAT Backdoor</h3><label>Server</label><input value="127.0.0.1"></div>`,
        inputs: 1, outputs: 1, name: "RAT"
        },
        "Delay": {
        html: `<div><h3>üïí Delay</h3><label>Duration (s)</label><input type="number" value="2"></div>`,
        inputs: 1, outputs: 1, name: "Delay"
        },
        "End": {
        html: `<div><h3>üîö Do nothing, end.</h3><label>End Node</label></div>`,
        inputs: 1, outputs: 0, name: "End"
        }
    };

    const container = document.getElementById("drawflow");
    const editor = new Drawflow(container);
    editor.reroute = true;
    editor.start();

    const drawflowContainer = document.getElementById("drawflow");

    // Holds the current selected node DOM elements
    let selectedNodes = [];

    let multiListenersActive = false;
    function updateSelectedNodes() {
        selectedNodes = Array.from(document.querySelectorAll('.drawflow-node.custom-selected'));
        if (selectedNodes.length > 1 && !multiListenersActive) {
            enableMultiNodeListeners();
            multiListenersActive = true;
        } else if (selectedNodes.length <= 1 && multiListenersActive) {
            disableMultiNodeListeners();
            multiListenersActive = false;
        }
    }

    // Use event delegation for dynamic nodes
    drawflowContainer.addEventListener("click", function (e) {
    const node = e.target.closest(".drawflow-node");
    const isCtrl = e.ctrlKey || e.metaKey;

    if (!node && !isCtrl) {
        document.querySelectorAll(".drawflow-node.custom-selected").forEach(n =>
        n.classList.remove("custom-selected")
        );
        updateSelectedNodes();
        return;
    }
    if (node) {
        if (isCtrl) {
        node.classList.toggle("custom-selected");
        } else {
        document.querySelectorAll(".drawflow-node.custom-selected").forEach(n =>
            n.classList.remove("custom-selected")
        );
        node.classList.add("custom-selected");
        }
        updateSelectedNodes();
        e.stopPropagation();
    }
    });

    // Ctrl+A
    document.addEventListener("keydown", function (e) {
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "a") {
        e.preventDefault();
        document.querySelectorAll(".drawflow-node").forEach(n =>
        n.classList.add("custom-selected")
        );
        updateSelectedNodes();
    }
    });

    // On page load, make sure array is in sync
    updateSelectedNodes();


    function enableMultiNodeListeners() {
        // --- DELETE MULTIPLE NODES ---
        document.addEventListener("keydown", multiDeleteHandler, true);

        // --- GROUP DRAG ---
        drawflowContainer.addEventListener("mousedown", groupDragMouseDown, true);
        document.addEventListener("mousemove", groupDragMouseMove, true);
        document.addEventListener("mouseup", groupDragMouseUp, true);
    }

    function disableMultiNodeListeners() {
        document.removeEventListener("keydown", multiDeleteHandler, true);
        drawflowContainer.removeEventListener("mousedown", groupDragMouseDown, true);
        document.removeEventListener("mousemove", groupDragMouseMove, true);
        document.removeEventListener("mouseup", groupDragMouseUp, true);
    }

        
    function multiDeleteHandler(e) {
    if ((e.key === "Delete" || e.key === "Backspace") && selectedNodes.length > 1) {
        e.preventDefault();
        e.stopImmediatePropagation();

        document.querySelectorAll('.drawflow-node.selected').forEach(n => n.classList.remove('selected'));
        if (typeof editor.selected_node !== "undefined") editor.selected_node = null;

        const idsToDelete = selectedNodes
        .map(node => node.id.replace("node-", ""))
        .sort((a, b) => b - a);

        for (let i = 0; i < idsToDelete.length; ++i) {
        const nodeId = idsToDelete[i];
        if (editor.drawflow.drawflow.Home.data[nodeId]) {
            editor.removeNodeId('node-' + nodeId);
        }
        }
        setTimeout(() => updateSelectedNodes(), 10);
        return;
    }
    }

    // Dragging group
    let isGroupDragging = false;
    let groupDragStart = { x: 0, y: 0 };
    let nodesDragStart = [];

    function groupDragMouseDown(e) {
    if (selectedNodes.length <= 1) return;
    const node = e.target.closest(".drawflow-node.custom-selected");
    if (node && e.button === 0) {
        isGroupDragging = true;
        groupDragStart.x = e.clientX;
        groupDragStart.y = e.clientY;
        nodesDragStart = selectedNodes.map(n => {
        const nodeId = n.id.replace("node-", "");
        const nodeData = editor.getNodeFromId(nodeId);
        return {
            node: n,
            nodeId: nodeId,
            startX: nodeData.pos_x,
            startY: nodeData.pos_y
        };
        });
        document.body.style.userSelect = "none";
    }
    }

    function groupDragMouseMove(e) {
    if (!isGroupDragging) return;
    const dx = e.clientX - groupDragStart.x;
    const dy = e.clientY - groupDragStart.y;
    nodesDragStart.forEach(item => {
        const newX = item.startX + dx;
        const newY = item.startY + dy;
        item.node.style.left = newX + "px";
        item.node.style.top = newY + "px";
        const nodeData = editor.getNodeFromId(item.nodeId);
        if (nodeData) {
        nodeData.pos_x = newX;
        nodeData.pos_y = newY;
        // *** Force Drawflow to update connection lines for this node ***
        if (typeof editor.updateConnectionNodes === "function") {
            editor.updateConnectionNodes('node-' + item.nodeId);
        }
        }
    });
    }

    function groupDragMouseUp(e) {
    if (isGroupDragging) {
        isGroupDragging = false;
        nodesDragStart = [];
        document.body.style.userSelect = "";
    }
    }


    const TOOLBOX_ITEMS = {
    Malware: [
        {label: "üíÄ Trigger BSOD", action: () => addBlueprintNode('TriggerBSOD')},
        {label: "üî• Screen Melter", action: () => addBlueprintNode('ScreenMelter')},
        {label: "üîê Ransomware", action: () => addBlueprintNode('Ransomware')},
        {label: "‚ö†Ô∏è Popup Spam", action: () => addBlueprintNode('PopupSpam')},
        {label: "üé® Background Changer", action: () => addBlueprintNode('BackgroundChanger')}
    ],
    Logic: [
        {label: "üì¶ Add Variable", action: () => addBlueprintNode('Variable')},
        {label: "üî• Get Variable", action: () => addBlueprintNode('VariableGet')},
        {label: "‚úèÔ∏è Set Variable", action: () => addBlueprintNode('VariableSet')},
        {label: "üß© If Boolean Condition", action: () => addBlueprintNode('IfCond')},
        {label: "üïí Delay", action: () => addBlueprintNode('Delay')}
    ],
    Monitoring: [
        {label: "üí¨ Popup Messagebox", action: () => addBlueprintNode('PopupShow')}
    ],
    Main: [
        {label: "‚ñ∂Ô∏è Start Function", action: () => addBlueprintNode('Start')},
        {label: "üîö End Node", action: () => addBlueprintNode('End')}
    ],
    File: [
        {label: "üíæ Save Blueprint", action: () => saveBlueprint()},
        {label: "‚ñ∂Ô∏è Run Blueprint", action: () => runCurrentBlueprint()},
        {label: "‚ñ∂Ô∏è Load Blueprint", action: () => loadBlueprint()},
        {label: "‚ñ∂Ô∏è Export Blueprint", action: () => exportBlueprint()}
    ]
    };

    function renderToolbox(cat, filter = "") {
        const box = document.getElementById("toolbox-list");
        box.innerHTML = "";

        // If filter is empty, show only current category, else show results from all
        let items;
        if (!filter.trim()) {
            items = TOOLBOX_ITEMS[cat] || [];
        } else {
            // Flatten all categories into one array
            items = Object.values(TOOLBOX_ITEMS)
                .flat()
                .filter(item => item.label.toLowerCase().includes(filter.toLowerCase()));
        }

        if (items.length === 0) {
            box.innerHTML = `<div class="toolbox-empty">No nodes found.</div>`;
            return;
        }
        for (const { label, action } of items) {
            const btn = document.createElement("button");
            btn.className = "toolbox-btn";
            btn.textContent = label;
            btn.onclick = action;
            box.appendChild(btn);
        }
    }

    function setActiveTab(cat) {
        document.querySelectorAll('.toolbox-tab').forEach(tab =>
            tab.classList.toggle('active', tab.dataset.cat === cat)
        );
    }
    let currentCat = "Malware";
    renderToolbox(currentCat);
    setActiveTab(currentCat);

    document.querySelectorAll('.toolbox-tab').forEach(tab => {
        tab.onclick = () => {
            currentCat = tab.dataset.cat;
            setActiveTab(currentCat);
            document.getElementById("toolbox-search").value = "";
            renderToolbox(currentCat);
        }
    });
    document.getElementById("toolbox-search").oninput = e => {
        renderToolbox(currentCat, e.target.value);
    };

    let lastMouseX = 300;
    let lastMouseY = 100;

    drawflowContainer.addEventListener("mousemove", function(e) {
        // Only update if mouse is inside the canvas
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
    });

    function getCanvasViewportCenterCoords() {
        const rect = drawflowContainer.getBoundingClientRect();
        const precanvas = document.querySelector('.drawflow .precanvas') || editor.precanvas;
        let zoom = 1, panX = 0, panY = 0;

        // Try to read from style.transform: "matrix(a, b, c, d, tx, ty)"
        if (precanvas && precanvas.style.transform) {
            // Example: "matrix(1, 0, 0, 1, -800, -1200)"
            const match = precanvas.style.transform.match(/matrix\(([^,]+),[^,]+,[^,]+,[^,]+,([^,]+),([^)]+)\)/);
            if (match) {
            zoom = parseFloat(match[1]) || 1;
            panX = parseFloat(match[2]) || 0;
            panY = parseFloat(match[3]) || 0;
            } else {
            // Try: "translate(Xpx, Ypx) scale(Z)"
            const trans = precanvas.style.transform;
            const translateMatch = trans.match(/translate\(([^p]+)px,\s*([^p]+)px\)/);
            const scaleMatch = trans.match(/scale\(([^)]+)\)/);
            if (translateMatch) {
                panX = parseFloat(translateMatch[1]);
                panY = parseFloat(translateMatch[2]);
            }
            if (scaleMatch) {
                zoom = parseFloat(scaleMatch[1]);
            }
            }
        } else {
            // fallback (legacy)
            zoom = editor.zoom || 1;
            panX = parseInt(precanvas?.style.left || 0, 10) || 0;
            panY = parseInt(precanvas?.style.top  || 0, 10) || 0;
        }

        // Center of the visible area in viewport pixels
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        // Now convert to canvas space
        return {
            x: ((centerX - rect.left) - panX) / zoom,
            y: ((centerY - rect.top) - panY) / zoom
        };
    }


    console.log("‚úÖ UE-style Blueprint Editor Ready");
    const allVariables = {};

    function addBlueprintNode(type) {
    if (type === "Variable") {
        setTimeout(() => {
            // Find the last (newest) variable node only!
            const nodes = document.querySelectorAll('.drawflow-node');
            const el = nodes[nodes.length - 1];
            const nameInput = el.querySelector('.var-name');
            const typeInput = el.querySelector('.var-type');
            const valueInput = el.querySelector('.var-value');

            // Store the previous name for this node
            let prevVarName = nameInput.value;

            function updateVarMap() {
                const varName = nameInput.value;
                const varType = typeInput.value;
                let varValue;
                if (varType === "boolean") {
                    varValue = valueInput.checked;
                } else if (varType === "number") {
                    varValue = parseFloat(valueInput.value) || 0;
                } else {
                    varValue = valueInput.value;
                }

                // Remove old variable if name changed
                if (prevVarName && prevVarName !== varName && allVariables[prevVarName]) {
                    delete allVariables[prevVarName];
                }
                if (varName) {
                    allVariables[varName] = { type: varType, value: varValue };
                }
                prevVarName = varName;
                updateVariableDropdowns();
            }

            nameInput.addEventListener('input', updateVarMap);
            typeInput.addEventListener('change', () => {
                valueInput.type = typeInput.value === "boolean" ? "checkbox" : typeInput.value;
                updateVarMap();
            });
            valueInput.addEventListener('input', updateVarMap);
            valueInput.addEventListener('change', updateVarMap);

            // Initial setup
            updateVarMap();
        }, 20);
    }

    if (type === "PopupShow") {
        setTimeout(() => {
            const nodes = document.querySelectorAll('.drawflow-node');
            const el = nodes[nodes.length - 1];
            const checkbox = el.querySelector('.popup-use-var');
            const msgInput = el.querySelector('.popup-msg-input');

            // Store to drawflow data (node.values) on change:
            function updateInputVisibility() {
                msgInput.style.display = checkbox.checked ? "none" : "";
                document.getElementById('popupmsg').style.display = checkbox.checked ? "none" : "";
                // Save the state in the node's data
                const nodeId = el.id.replace("node-", "");
                const nodeData = editor.getNodeFromId(nodeId);
                if (nodeData) {
                    nodeData.values = nodeData.values || {};
                    nodeData.values.useVariable = checkbox.checked;
                    nodeData.values.message = msgInput.value;
                }
            }

            // Also save value change
            msgInput.addEventListener('input', updateInputVisibility);
            checkbox.addEventListener('change', updateInputVisibility);

            // Initial setup
            updateInputVisibility();
        }, 20);
    }


    const { x, y } = getCanvasViewportCenterCoords();

    let node = nodeInfo[type];
    console.log('Spawning at', lastMouseX, lastMouseY, 'canvas:', x, y);

    // Prid√° nov√Ω node s menom, poz√≠ciou random (alebo daj lep≈°ie)
    editor.addNode(node.name, node.inputs, node.outputs, 
        x,y, 
        node.name.toLowerCase(), {}, node.html);

        updateVariableDropdowns();

    }


    function runBlueprint(cleanBp) {
        // 1. Find Start node
        let startId = Object.keys(cleanBp).find(id => cleanBp[id].name === "Start");
        if (!startId) return;

        let currId = startId;
        let runtimeVars = {};
        let lastValue = undefined; // used to pass values between nodes

        // Helper: get next nodeId by output index (default 0)
        function getNextId(node, outIdx = 0) {
            const outs = node.outputs && Object.values(node.outputs);
            if (outs && outs[outIdx] && outs[outIdx][0])
                return outs[outIdx][0].node;
            return null;
        }

        // Helper: get connected nodeId for input idx
        function getInputId(node, inputIdx = 0) {
            const ins = node.inputs && Object.values(node.inputs);
            if (ins && ins[inputIdx] && ins[inputIdx][0])
                return ins[inputIdx][0].node;
            return null;
        }

        // Helper: recursively evaluate a value input (for Get/Set/IfCond)
        function evalInput(node, inputIdx = 1) {
            let inputNodeId = getInputId(node, inputIdx);
            if (!inputNodeId) return undefined;
            let inputNode = cleanBp[inputNodeId];
            if (!inputNode) return undefined;

            if (inputNode.name === "Get Variable") {
                let vName = inputNode.values && inputNode.values.name;
                return runtimeVars[vName];
            }
            if (inputNode.name === "Set Variable") {
                let vName = inputNode.values && inputNode.values.name;
                let vValue = evalInput(inputNode, 1); // supports chaining
                runtimeVars[vName] = vValue;
                return vValue;
            }
            if (inputNode.name === "IfCond") {
                // Recursively evaluate its branch
                let cond = evalInput(inputNode, 1);
                if (cond) return runNode(inputNode, 0); // TRUE branch
                else     return runNode(inputNode, 1); // FALSE branch
            }
            // Could add: Constant node, Boolean node, etc.
            return inputNode.values && inputNode.values.value;
        }

        // Init all variables before starting!
        for (let id in cleanBp) {
            let node = cleanBp[id];
            if (node.name === "Variable") {
                let vName = node.values && node.values.name;
                let vType = node.values && node.values.type;
                let vValue = node.values && node.values.value;
                if (vType === "boolean") vValue = vValue === "on" || vValue === true || vValue === "true";
                else if (vType === "number") vValue = parseFloat(vValue) || 0;
                runtimeVars[vName] = vValue;
            }
        }


        // Main executor for a node, with output branch (for IfCond)
        function runNode(node, outIdx = 0) {
            switch (node.name) {
                case "Set Variable": {
                    let vName = node.values && node.values.name;
                    let vValue = evalInput(node, 1); // get value from input 1 (Value)
                    runtimeVars[vName] = vValue;
                    // Continue to next node (output 0)
                    let nextId = getNextId(node, 0);
                    if (nextId) runNode(cleanBp[nextId]);
                    break;
                }
                case "Get Variable": {
                    // Just pass its value to next
                    let vName = node.values && node.values.name;
                    let value = runtimeVars[vName];
                    let nextId = getNextId(node, 0);
                    if (nextId) runNode(cleanBp[nextId]);
                    return value;
                }
                case "IfCond": {
                    // input 1 is the boolean value to check
                    let cond = evalInput(node, 1);
                    let branch = cond ? 0 : 1; // 0 = TRUE, 1 = FALSE
                    let nextId = getNextId(node, branch);
                    if (nextId) runNode(cleanBp[nextId]);
                    break;
                }
                case "PopupShow": {
                    // If useVariable, evaluate input 1 (the wire must connect to GetVariable node)
                    let text;
                    if (node.values && node.values.useVariable) {
                        text = evalInput(node, 1); // This will call GetVariable and get its value
                    } else {
                        text = node.values && node.values.message;
                    }
                    let nextId = getNextId(node, 0);
                    if (nextId) runNode(cleanBp[nextId]);
                    break;
                }
                case "Start": {
                    let nextId = getNextId(node, 0);
                    if (nextId) runNode(cleanBp[nextId]);
                    break;
                }
                default: {
                    // Other nodes: just follow output 0
                    let nextId = getNextId(node, outIdx);
                    if (nextId) runNode(cleanBp[nextId]);
                    break;
                }
            }
        }

        // --- Start execution from Start node ---
        runNode(cleanBp[startId]);
        return runtimeVars; // (optional, for debugging)
    }

    function runCurrentBlueprint() {
        let clean = getCleanBlueprint(editor);
        let logicErrors = checkBlueprintLogic(clean);
        if (logicErrors.length) {
            alert("‚ùå Logic Error:\n" + logicErrors.join('\n'));
            return;
        }
        alert("‚úÖ Logic is OK and ready to run!");
        runBlueprint(clean);
    }


    function updateVariableDropdowns() {
    // For Get Variable
    document.querySelectorAll('.var-get-name').forEach(select => {
        const currentVal = select.value;
        select.innerHTML = Object.keys(allVariables)
        .map(name => `<option value="${name}">${name}</option>`).join('');
        if (allVariables[currentVal]) select.value = currentVal;
    });

    // For Set Variable
    document.querySelectorAll('.var-set-name').forEach(select => {
        const currentVal = select.value;
        select.innerHTML = Object.keys(allVariables)
        .map(name => `<option value="${name}">${name}</option>`).join('');
        if (allVariables[currentVal]) select.value = currentVal;
        // Update value input type based on variable type
        const node = select.closest('.drawflow-node');
        if (node) {
        const valueInput = node.querySelector('.var-set-value');
        if (allVariables[select.value]) {
            const t = allVariables[select.value].type;
            valueInput.type = t === "boolean" ? "checkbox" : t;
        }
        }
        select.onchange = function () {
        const node = select.closest('.drawflow-node');
        const valueInput = node.querySelector('.var-set-value');
        if (allVariables[select.value]) {
            const t = allVariables[select.value].type;
            valueInput.type = t === "boolean" ? "checkbox" : t;
            // Reset value to current var value
            if (t === "boolean") valueInput.checked = !!allVariables[select.value].value;
            else valueInput.value = allVariables[select.value].value || "";
        }
        }
    });
    }


    function saveBlueprint() {
        let virusName = prompt("Name your virus:", "MyEpicVirus");
        if (!virusName) return;

        let clean = getCleanBlueprint(editor);
        let logicErrors = checkBlueprintLogic(clean);
        if (logicErrors.length) {
            alert("‚ùå Compile error:\n" + logicErrors.join('\n'));
            return;
        }

        fetch('/save-blueprint', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
            name: virusName,
            blueprint: clean
            })
        })
        .then(res => res.json())
        .then(resp => {
            if(resp.success){
            alert("‚úÖ Virus saved as " + virusName + ".json!");
            } else {
            alert("‚ùå Save failed: " + resp.error);
            }
        })
        .catch(err => alert("‚ùå Network/server error: " + err));
    }


    function getCleanBlueprint(editor) {
        const data = editor.export().drawflow.Home.data;
        let result = {};
        for (let nodeId in data) {
            let node = data[nodeId];

            // Najdi DOM node podƒæa id (Drawflow d√°va id="node-{id}")
            const domNode = document.querySelector(`#node-${nodeId}`);
            let inputValues = {};

            if(domNode) {
                // Prejdi v≈°etky inputy, textarea, select v node
                domNode.querySelectorAll('input, textarea, select').forEach(input => {
                    let key = input.previousElementSibling && input.previousElementSibling.tagName === "LABEL"
                        ? input.previousElementSibling.innerText.trim().toLowerCase().replace(/\W+/g, "_")
                        : (input.name || input.type || "input");
                    // Fix for boolean: save true/false, not "on"
                    if (input.type === "checkbox") {
                        inputValues[key] = input.checked;
                    } else {
                        if (input.classList.contains("popup-msg-input") && domNode.querySelector(".popup-use-var")?.checked) {
                        // Do not save message if "Use Variable" is checked
                        } else {
                        inputValues[key] = input.value;
                        }
                    }
                });
            }

            // connections
            let outputs = {};
            for (let outKey in node.outputs) {
                outputs[outKey] = node.outputs[outKey].connections.map(conn => ({
                    node: conn.node,
                    output: conn.output
                }));
            }
            let inputs = {};
            for (let inKey in node.inputs) {
                inputs[inKey] = node.inputs[inKey].connections.map(conn => ({
                    node: conn.node,
                    input: conn.input
                }));
            }

            result[nodeId] = {
                id: node.id,
                name: node.name,
                class: node.class,
                values: inputValues,   // <--- Toto obsahuje re√°lne zadan√© hodnoty!
                inputs,
                outputs,
                pos_x: node.pos_x,
                pos_y: node.pos_y
            };
        }
        return result;
    }

    function checkBlueprintLogic(cleanBp) {
        let errors = [];
        if (!cleanBp || Object.keys(cleanBp).length === 0) {
            errors.push("Blueprint is empty! Please add some nodes before running.");
            return errors;
        }

        for (let id in cleanBp) {
            const n = cleanBp[id];

            // These node types do not need input/output checks
            const skipInput = ["Start", "InputKey", "Variable"];
            const skipOutput = ["End", "TriggerBSOD", "Variable", "VariableGet", "VariableSet"];

            // Input: skip for some types
            if (
                !Object.values(n.inputs).some(conns => conns.length > 0)
                && !skipInput.includes(n.name)
            ) {
                errors.push(`Node ${n.name} (#${id}) is not connected to any input`);
            }

            // Output: skip for some types
            if (
                !Object.values(n.outputs).some(conns => conns.length > 0)
                && !skipOutput.includes(n.name)
            ) {
                errors.push(`Node ${n.name} (#${id}) does not output to any node`);
            }

            if (
                n.name === "PopupShow" &&
                (n.values.use_variable || n.values.useVariable)
            ) {
                // Check if input_1 is connected
                if (!n.inputs.input_1 || n.inputs.input_1.length === 0) {
                    errors.push(`Popup Messagebox (#${id}) is set to use a variable, but is not connected to any input! Connect a Variable Get node.`);
                } else {
                    // Get the connected node's ID
                    const inputNodeId = n.inputs.input_1[0].node;
                    const inputNode = cleanBp[inputNodeId];
                    if (!inputNode || inputNode.name !== "VariableGet") {
                        errors.push(`Popup Messagebox (#${id}) is set to use a variable, but its input is not a Variable Get node!`);
                    }
                }
            }


            // IfCond can have only one or zero outputs, that's fine
            if (n.name === "IfCond") {
                // Do not error if only one branch is connected
                // (Handled above by skipOutput)
            }
        }
        return errors;
    }

    const dropzone = document.getElementById("dropzone");

    // Show dropzone on drag over
    window.addEventListener("dragover", e => {
    e.preventDefault();
    dropzone.style.display = "flex";
    });

    // Hide dropzone on drag leave
    window.addEventListener("dragleave", e => {
    if (e.target === dropzone || e.clientY <= 0) {
        dropzone.style.display = "none";
    }
    });

    // Handle file drop
    window.addEventListener("drop", e => {
    e.preventDefault();
    dropzone.style.display = "none";
    const file = e.dataTransfer.files[0];
    if (file && file.type === "application/json") {
        const reader = new FileReader();
        reader.onload = function(event) {
        try {
            const json = JSON.parse(event.target.result);
            if (confirm("Do you want to load this blueprint?")) {
            loadBlueprint(json);
            }
        } catch (err) {
            alert("‚ùå Failed to parse JSON file!" + err);
        }
        };
        reader.readAsText(file);
    } else if (file) {
        alert("‚ùå Please drop a valid JSON file!");
    }
    });


function exportBlueprint() {
    // 1) Z√≠skame cel√Ω export (vr√°tane version!)
    const fullExport = editor.export();

    // 2) Zist√≠me meno s√∫boru
    const name = prompt("Ako sa m√° blueprint vola≈•?", "MyBlueprint") || "MyBlueprint";

    // 3) Vytvor√≠me payload
    const payload = {
        name: name,
        drawflow: fullExport.drawflow,
        version: fullExport.version || '1.0'
    };

    // 4) Serializujeme
    const jsonStr = JSON.stringify(payload, null, 2);

    // 5) Ulo≈æ√≠me ako .json s√∫bor
    const blob = new Blob([jsonStr], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = name + ".json";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}


function autofillNodeInputs(patchedBlueprint) {
    document.querySelectorAll('.drawflow-node').forEach(nodeEl => {
        const nodeId = nodeEl.id.replace("node-", "").trim();
        const nodeData = patchedBlueprint && patchedBlueprint.hasOwnProperty(nodeId)
            ? (patchedBlueprint[nodeId].values || {})
            : {};

        // --- Special handling for Variable nodes! ---
        const nameInput = nodeEl.querySelector('.var-name');
        const typeInput = nodeEl.querySelector('.var-type');
        const valueInput = nodeEl.querySelector('.var-value');
        if (nameInput && typeInput && valueInput) {
            // Autofill name
            if (nodeData.name) nameInput.value = nodeData.name;
            // Autofill type
            if (nodeData.type) {
                typeInput.value = nodeData.type;
                setTimeout(() => {
                    valueInput.type = nodeData.type === "boolean" ? "checkbox" : nodeData.type;
                    // Autofill value after type is set
                    if (typeof nodeData.value !== "undefined") {
                        if (nodeData.type === "boolean") {
                            valueInput.checked = !!nodeData.value;
                        } else {
                            valueInput.value = nodeData.value;
                        }
                    }
                }, 20);
            } else {
                // If no type, still fill value (text)
                if (typeof nodeData.value !== "undefined") {
                    valueInput.value = nodeData.value;
                }
            }
            return; // Skip generic
        }

        if (nodeEl.classList.contains("popupshow")) {
            const checkbox = nodeEl.querySelector('.popup-use-var');
            const msgInput = nodeEl.querySelector('.popup-msg-input');
            const label = nodeEl.querySelector('#popupmsg');
            // Restore state from values
            if (checkbox && typeof nodeData.use_variable !== "undefined") {
                checkbox.checked = !!nodeData.use_variable;
            }
            if (msgInput && nodeData.message) {
                msgInput.value = nodeData.message;
            }
            if (msgInput && nodeData.mining_power) {
                msgInput.value = nodeData.mining_power;
            }
            function updateInputVisibility() {
                msgInput.style.display = checkbox.checked ? "none" : "";
                if (label) label.style.display = checkbox.checked ? "none" : "";
            }
            // Rebind (so it works after import)
            checkbox && checkbox.addEventListener('change', updateInputVisibility);
            // Initial update (IMPORTANT!)
            updateInputVisibility();
            // Don't let generic autofill mess with this block
            return;
        }

        // --- GENERIC autofill for other nodes ---
        nodeEl.querySelectorAll('input, textarea, select').forEach(input => {
            let key = input.previousElementSibling && input.previousElementSibling.tagName === "LABEL"
                ? input.previousElementSibling.innerText.trim().toLowerCase().replace(/\W+/g, "_")
                : (input.name || input.type || "input");
            if (key in nodeData) {
                if (input.type === "checkbox") {
                    let v = nodeData[key];
                    input.checked = (typeof v === "boolean") ? v : (v === "true" || v === "on" || v === true);
                    input.dispatchEvent(new Event('change', { bubbles: true }));
                } else if (input.tagName === "SELECT") {
                    setTimeout(() => { input.value = nodeData[key] || ""; }, 10);
                } else if (input.type === "number" || input.type === "range") {
                    input.value = Number(nodeData[key]);
                } else {
                    input.value = nodeData[key];
                }
            }
        });
    });
}


function loadBlueprint(json) {

    // Ak je u≈æ spr√°vny drawflow form√°t (obsahuje 'drawflow' a 'version'), importuj priamo
    if (json.drawflow && json.version) {
        editor.clear();
        editor.import(json);
        setTimeout(updateVariableDropdowns, 50);
        return;
    }

    // Ak je to star√Ω tvoj form√°t (obsahuje .blueprint)
    if (json.blueprint) {
        // PATCH: Preveƒè na Drawflow form√°t
        const patchedNodes = {};
        for (const [nodeId, node] of Object.entries(json.blueprint)) {
            const idStr = String(nodeId);
            // Priprav z√°kladn√© pole
            const patched = {
                id: idStr,
                name: node.name,
                class: node.class,
                html: nodeInfo[node.name]?.html || `<div><h3>${node.name}</h3></div>`,
                data: node.values || {}, // <-- THIS IS CRUCIAL
                values: node.values || {},
                typenode: false,
                pos_x: node.pos_x || 0,
                pos_y: node.pos_y || 0,
                inputs: {},
                outputs: {}
            };


            // PATCH INPUTS (Drawflow chce: {input_1:{connections:[...]}})
            for (const key in node.inputs || {}) {
                patched.inputs[key] = {
                    connections: (node.inputs[key] || []).map(conn => ({
                        node: String(conn.node),
                        input: conn.input
                    }))
                };
            }
            // PATCH OUTPUTS
            for (const key in node.outputs || {}) {
                patched.outputs[key] = {
                    connections: (node.outputs[key] || []).map(conn => ({
                        node: String(conn.node),
                        output: conn.output
                    }))
                };
            }

            patchedNodes[idStr] = patched;
        }

        // Zabaƒæ do spr√°vneho drawflow tvaru
        const drawflowFormat = {
            drawflow: {
                Home: {
                    data: patchedNodes,
                    position: { x: 0, y: 0, zoom: 1 }
                }
            },
            version: "1.0"
        };

        // IMPORTUJ
        try {
            editor.clear();
            editor.import(drawflowFormat);
            setTimeout(() => {
                autofillNodeInputs(patchedNodes);
                updateVariableDropdowns();
                refreshAllVariablesFromDOM();
            }, 60);  // d√°vam 60ms, nech je istota ≈æe DOM nody s√∫ u≈æ pridan√©

            setTimeout(updateVariableDropdowns, 50);
        } catch (e) {
            alert("‚ùå Failed to import blueprint!\n" + e.message);
            console.error("Drawflow import error:", e, drawflowFormat);
        }
        return;
    }

    // Ak niƒç nesed√≠, fail
    alert("Invalid or unsupported blueprint JSON!");
}

function refreshAllVariablesFromDOM() {
    // Vynuluj allVariables
    Object.keys(allVariables).forEach(k => delete allVariables[k]);
    // Prejdi v≈°etky Variable nody
    document.querySelectorAll('.drawflow-node').forEach(el => {
        if (el.querySelector('.var-name')) {
            const name = el.querySelector('.var-name').value;
            const type = el.querySelector('.var-type').value;
            let value;
            if (type === "boolean") value = el.querySelector('.var-value').checked;
            else if (type === "number") value = parseFloat(el.querySelector('.var-value').value);
            else value = el.querySelector('.var-value').value;
            if (name) allVariables[name] = { type, value };
        }
    });
    updateVariableDropdowns();
}
  </script>
</body>
</html>
